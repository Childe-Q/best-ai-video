import { PricingPlan } from '@/types/tool';

// Style tone profiles for different approaches (deterministic selection by slug hash)
const STYLE_PROFILES = {
  product: {
    tone: 'product-focused',
    sentence1_patterns: [
      '{toolName} works best for {target} who need {specific_feature}.',
      'Perfect for {target} requiring {specific_feature} in their workflow.',
      '{toolName} is designed for {target} focused on {specific_feature}.'
    ],
    sentence2_patterns: [
      'You get {differentiator} plus {secondary_feature}.',
      'Upgrading unlocks {differentiator} and {secondary_feature}.',
      'Paid plans deliver {differentiator} alongside {secondary_feature}.'
    ],
    sentence3_patterns: [
      'Start with {plan_recommendation} to test {specific_limit}, then scale up.',
      'Begin with monthly {plan_recommendation} for {specific_limit} before committing.',
      'Try {plan_recommendation} first - it includes {specific_limit} for evaluation.'
    ]
  },
  review: {
    tone: 'evaluation-focused',
    sentence1_patterns: [
      '{toolName} stands out for {target} who prioritize {specific_feature}.',
      'Best suited for {target} when {specific_feature} is essential.',
      'Ideal choice for {target} requiring reliable {specific_feature}.'
    ],
    sentence2_patterns: [
      'The main value is {differentiator} combined with {secondary_feature}.',
      'Key benefits include {differentiator} and {secondary_feature}.',
      'You gain access to {differentiator} plus {secondary_feature}.'
    ],
    sentence3_patterns: [
      'Consider {plan_recommendation} for {specific_limit} to evaluate fit.',
      'Test drive with {plan_recommendation} - includes {specific_limit}.',
      'Start with {plan_recommendation} to assess {specific_limit} needs.'
    ]
  },
  growth: {
    tone: 'scale-focused',
    sentence1_patterns: [
      '{toolName} scales with {target} ready to leverage {specific_feature}.',
      'Built for {target} planning to maximize {specific_feature}.',
      'Optimal for {target} scaling operations with {specific_feature}.'
    ],
    sentence2_patterns: [
      'Investment pays off through {differentiator} and {secondary_feature}.',
      'ROI comes from {differentiator} plus {secondary_feature}.',
      'Value scales via {differentiator} combined with {secondary_feature}.'
    ],
    sentence3_patterns: [
      'Scale smartly with {plan_recommendation} - test {specific_limit} first.',
      'Grow efficiently using {plan_recommendation} for {specific_limit}.',
      'Expand with {plan_recommendation} to validate {specific_limit}.'
    ]
  },
  creator: {
    tone: 'content-focused',
    sentence1_patterns: [
      '{toolName} empowers {target} creating content with {specific_feature}.',
      'Perfect for {target} producing content requiring {specific_feature}.',
      'Made for {target} who create content using {specific_feature}.'
    ],
    sentence2_patterns: [
      'Your content gets {differentiator} and {secondary_feature}.',
      'Creative output benefits from {differentiator} plus {secondary_feature}.',
      'Content quality improves with {differentiator} and {secondary_feature}.'
    ],
    sentence3_patterns: [
      'Create confidently with {plan_recommendation} - includes {specific_limit}.',
      'Start creating using {plan_recommendation} for {specific_limit}.',
      'Begin your content journey with {plan_recommendation} at {specific_limit}.'
    ]
  },
  team: {
    tone: 'collaboration-focused',
    sentence1_patterns: [
      '{toolName} connects {target} collaborating on {specific_feature}.',
      'Essential for {target} working together on {specific_feature}.',
      'Designed for {target} coordinating {specific_feature} projects.'
    ],
    sentence2_patterns: [
      'Teams access {differentiator} plus {secondary_feature} together.',
      'Collaboration improves with {differentiator} and {secondary_feature}.',
      'Shared workflows benefit from {differentiator} plus {secondary_feature}.'
    ],
    sentence3_patterns: [
      'Coordinate with {plan_recommendation} - supports {specific_limit}.',
      'Unite your team using {plan_recommendation} for {specific_limit}.',
      'Collaborate effectively with {plan_recommendation} including {specific_limit}.'
    ]
  },
  tutorial: {
    tone: 'educational-focused',
    sentence1_patterns: [
      '{toolName} teaches {target} to master {specific_feature}.',
      'Learn-friendly for {target} developing {specific_feature} skills.',
      'Educational value for {target} practicing {specific_feature}.'
    ],
    sentence2_patterns: [
      'Learning accelerates with {differentiator} and {secondary_feature}.',
      'Skill development uses {differentiator} plus {secondary_feature}.',
      'Education improves through {differentiator} and {secondary_feature}.'
    ],
    sentence3_patterns: [
      'Learn effectively with {plan_recommendation} - practice with {specific_limit}.',
      'Develop skills using {plan_recommendation} for {specific_limit}.',
      'Master the basics with {plan_recommendation} including {specific_limit}.'
    ]
  }
};

/**
 * Select style profile based on deterministic slug hash (no randomness)
 */
function selectStyleProfile(slug: string) {
  const profiles = Object.keys(STYLE_PROFILES);
  const hash = slug.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
  const index = hash % profiles.length;
  const selectedProfile = profiles[index];
  return STYLE_PROFILES[selectedProfile as keyof typeof STYLE_PROFILES];
}

/**
 * Extract target audience and specific feature
 */
function extractTargetAndFeature(toolData: any, plans: PricingPlan[] | undefined, combinedText: string, usedKeywords: Set<string>, extractedFacts: Set<string>) {
  let target = 'content creators';
  let specificFeature = 'video production';
  
  // Extract target from best_for, highlights, or key_facts
  if (toolData?.best_for) {
    if (toolData.best_for.toLowerCase().includes('team')) {
      target = 'teams';
    } else if (toolData.best_for.toLowerCase().includes('enterprise')) {
      target = 'enterprises';
    } else if (toolData.best_for.toLowerCase().includes('marketer')) {
      target = 'marketers';
    } else if (toolData.best_for.toLowerCase().includes('educator')) {
      target = 'educators';
    }
  }
  
  // Extract specific feature with numbers/keywords
  const featureMatches = [
    combinedText.match(/\b(4k|1080p)\s*(export|video|output)\b/i),
    combinedText.match(/\b(\d+)\s*(hr|hours?)\s*(subtitles?|captions?)\b/i),
    combinedText.match(/\b(\d+)\s*(minutes?|mins?)\s*(per\s+month|\/mo)?\b/i),
    combinedText.match(/\b(watermark\s+removal|no\s+watermark)\b/i),
    combinedText.match(/\b(voice\s+cloning|ai\s+voices?)\b/i),
    combinedText.match(/\b(sso|saml|scorm)\b/i),
    combinedText.match(/\b(\d+)\+?\s*languages?\b/i),
    combinedText.match(/\b(team\s+collaboration|workspace|seats?)\b/i)
  ].filter(Boolean);
  
  if (featureMatches.length > 0) {
    const match = featureMatches[0];
    if (match) {
      if (match[0].includes('4k') || match[0].includes('1080p')) {
        specificFeature = match[0].includes('4k') ? '4K export quality' : '1080p video export';
      } else if (match[0].includes('hr') || match[0].includes('hours')) {
        specificFeature = `${match[1]} hr/month subtitle generation`;
      } else if (match[0].includes('minute')) {
        specificFeature = `${match[1]} minutes/month video creation`;
      } else if (match[0].includes('watermark')) {
        specificFeature = 'watermark-free exports';
      } else if (match[0].includes('voice')) {
        specificFeature = 'AI voice cloning';
      } else if (match[0].includes('sso') || match[0].includes('scorm')) {
        specificFeature = 'enterprise integrations (SSO/SCORM)';
      } else if (match[0].includes('language')) {
        specificFeature = `${match[1]}+ language support`;
      } else if (match[0].includes('team') || match[0].includes('collaboration')) {
        specificFeature = 'team collaboration features';
      }
      usedKeywords.add(match[0].toLowerCase());
      extractedFacts.add(specificFeature);
    }
  }
  
  return { target, specificFeature };
}

/**
 * Extract value proposition differentiators
 */
function extractValueProposition(planTexts: string[], toolData: any, combinedText: string, usedKeywords: Set<string>, extractedFacts: Set<string>) {
  let differentiator = 'advanced video features';
  let secondaryFeature = 'professional templates';
  
  const allPlanText = planTexts.join(' ').toLowerCase();
  
  // Extract differentiators in priority order (avoid already used keywords)
  const differentiatorMatches = [
    { match: allPlanText.match(/\b4k|2160p\b/i), value: '4K export quality' },
    { match: allPlanText.match(/\b(watermark\s+removal|no\s+watermark)\b/i), value: 'watermark removal' },
    { match: allPlanText.match(/\b(\d+)\s*(hr|hours?)\s*subtitles?\b/i), value: (match: RegExpMatchArray) => `${match[1]} hr subtitle generation` },
    { match: allPlanText.match(/\b(\d+)\s*(minutes?|mins?)\s*(per\s+month|\/mo)?\b/i), value: (match: RegExpMatchArray) => `${match[1]} minutes/month` },
    { match: allPlanText.match(/\b(voice\s+cloning|ai\s+voices?)\b/i), value: 'AI voice cloning' },
    { match: allPlanText.match(/\b(sso|saml|scorm|lms)\b/i), value: 'enterprise security features' },
    { match: allPlanText.match(/\b(\d+)\+?\s*languages?\b/i), value: (match: RegExpMatchArray) => `${match[1]}+ languages` },
    { match: allPlanText.match(/\b(team|collaboration|workspace)\b/i), value: 'team collaboration tools' }
  ];
  
  for (const item of differentiatorMatches) {
    if (item.match && !usedKeywords.has(item.match[0].toLowerCase())) {
      differentiator = typeof item.value === 'function' ? item.value(item.match) : item.value;
      usedKeywords.add(item.match[0].toLowerCase());
      extractedFacts.add(differentiator);
      break;
    }
  }
  
  // Find secondary feature (different from differentiator)
  const secondaryMatches = [
    { match: allPlanText.match(/\b(\d+)\s*(gb|tb)\s*storage\b/i), value: (match: RegExpMatchArray) => `${match[1]}${match[2].toUpperCase()} storage` },
    { match: allPlanText.match(/\b(brand\s+kit|custom\s+branding)\b/i), value: 'brand customization' },
    { match: allPlanText.match(/\b(api\s+access|integrations?)\b/i), value: 'API integrations' },
    { match: allPlanText.match(/\b(priority\s+support|24\/7\s+support)\b/i), value: 'priority support' },
    { match: allPlanText.match(/\b(\d+)\s*(avatars?|characters?)\b/i), value: (match: RegExpMatchArray) => `${match[1]} custom avatars` }
  ];
  
  for (const item of secondaryMatches) {
    if (item.match && !usedKeywords.has(item.match[0].toLowerCase()) && !extractedFacts.has(typeof item.value === 'function' ? item.value(item.match) : item.value)) {
      secondaryFeature = typeof item.value === 'function' ? item.value(item.match) : item.value;
      usedKeywords.add(item.match[0].toLowerCase());
      extractedFacts.add(secondaryFeature);
      break;
    }
  }
  
  return { differentiator, secondaryFeature };
}

/**
 * Extract plan recommendation and specific limit
 */
function extractPlanRecommendation(plans: PricingPlan[] | undefined, usedKeywords: Set<string>, extractedFacts: Set<string>) {
  let planRecommendation = 'the starter plan';
  let specificLimit = 'basic features';
  
  if (plans && plans.length > 0) {
    // Sort plans by name for deterministic selection
    const sortedPlans = [...plans].sort((a, b) => {
      const nameA = (a.name || '').toLowerCase();
      const nameB = (b.name || '').toLowerCase();
      return nameA.localeCompare(nameB);
    });
    
    // Find first paid plan (not free)
    const paidPlan = sortedPlans.find(p => {
      const name = (p.name || '').toLowerCase();
      return !name.includes('free') && !name.includes('enterprise');
    });
    
    if (paidPlan) {
      planRecommendation = `${paidPlan.name || 'paid plan'}`;
      
      // Extract specific limit from this plan
      const planText = [
        ...(paidPlan.highlights || []),
        ...(paidPlan.featureItems?.map(f => f.text) || []),
        ...(paidPlan.features || [])
      ].join(' ').toLowerCase();
      
      const limitMatches = [
        planText.match(/\b(\d+)\s*(minutes?|mins?)\s*(per\s+month|\/mo)?\b/i),
        planText.match(/\b(\d+)\s*(hr|hours?)\s*(subtitles?|captions?)\b/i),
        planText.match(/\b(\d+)\s*(videos?)\s*(per\s+month|\/mo)?\b/i),
        planText.match(/\b(\d+)\s*(gb|tb)\s*storage\b/i),
        planText.match(/\b(1080p|4k)\s*(export|video|output)\b/i)
      ].filter(Boolean);
      
      if (limitMatches.length > 0) {
        const match = limitMatches[0];
        if (match) {
          if (match[0].includes('minute')) {
            specificLimit = `${match[1]} minutes/month`;
          } else if (match[0].includes('hr') || match[0].includes('hour')) {
            specificLimit = `${match[1]} hr subtitles/month`;
          } else if (match[0].includes('video')) {
            specificLimit = `${match[1]} videos/month`;
          } else if (match[0].includes('gb') || match[0].includes('tb')) {
            specificLimit = `${match[1]}${(match[2] || '').toUpperCase()} storage`;
          } else if (match[0].includes('1080p') || match[0].includes('4k')) {
            specificLimit = `${match[0].includes('4k') ? '4K' : '1080p'} export quality`;
          }
          extractedFacts.add(specificLimit);
        }
      }
    }
  }
  
  return { planRecommendation, specificLimit };
}

/**
 * Check if content is duplicated between sentences
 */
function isContentDuplicated(sentence1: string, sentence2: string, extractedFacts: Set<string>): boolean {
  const s1Words = sentence1.toLowerCase().split(/\s+/);
  const s2Words = sentence2.toLowerCase().split(/\s+/);
  
  // Check for significant word overlap (>3 meaningful words)
  const overlap = s1Words.filter(word => 
    s2Words.includes(word) && 
    word.length > 3 && 
    !['this', 'that', 'with', 'from', 'they', 'your', 'plan', 'plans'].includes(word)
  );
  
  return overlap.length > 3;
}

/**
 * Extract alternative differentiator to avoid duplication
 */
function extractAlternativeDifferentiator(planTexts: string[], toolData: any, usedKeywords: Set<string>): string | null {
  const allPlanText = planTexts.join(' ').toLowerCase();
  
  const alternativeMatches = [
    { match: allPlanText.match(/\b(api\s+access|webhook)\b/i), value: 'API access' },
    { match: allPlanText.match(/\b(white\s+label|custom\s+branding)\b/i), value: 'white-label options' },
    { match: allPlanText.match(/\b(unlimited\s+downloads|bulk\s+export)\b/i), value: 'unlimited downloads' },
    { match: allPlanText.match(/\b(priority\s+rendering|fast\s+processing)\b/i), value: 'priority processing' },
    { match: allPlanText.match(/\b(analytics|insights|metrics)\b/i), value: 'detailed analytics' }
  ];
  
  for (const item of alternativeMatches) {
    if (item.match && !usedKeywords.has(item.match[0].toLowerCase())) {
      usedKeywords.add(item.match[0].toLowerCase());
      return item.value;
    }
  }
  
  return null;
}

/**
 * Extract specific feature from plan texts
 */
function extractSpecificFeature(planTexts: string[], usedKeywords: Set<string>): string | null {
  const allPlanText = planTexts.join(' ').toLowerCase();
  
  const featureMatches = [
    { match: allPlanText.match(/\b(\d+)\s*(avatars?|characters?)\b/i), value: (match: RegExpMatchArray) => `${match[1]} custom avatars` },
    { match: allPlanText.match(/\b(\d+)\s*(templates?)\b/i), value: (match: RegExpMatchArray) => `${match[1]} templates` },
    { match: allPlanText.match(/\b(\d+)\s*(scenes?)\b/i), value: (match: RegExpMatchArray) => `${match[1]} scenes` }
  ];
  
  for (const item of featureMatches) {
    if (item.match && !usedKeywords.has(item.match[0].toLowerCase())) {
      return typeof item.value === 'function' ? item.value(item.match) : item.value;
    }
  }
  
  return null;
}

/**
 * Generate tool-specific verdict text from tool data and pricing plans
 * Output: 2-3 sentences (who it's for, what you get, next steps)
 * No risk/limitation messaging - positive product focus only
 * Must be deterministic and contain tool-specific keywords/numbers
 */
export function generateVerdictText(
  toolData?: {
    key_facts?: string[];
    highlights?: string[];
    best_for?: string;
    stand_out_metrics?: string[];
  },
  plans?: PricingPlan[],
  toolName?: string,
  toolSlug?: string,
  snapshotBullets?: string[],
  comparableAttributes?: any[]
): string {
  // Select style profile based on deterministic slug hash
  const styleProfile = selectStyleProfile(toolSlug || toolName || 'default');
  
  // Collect all text sources (deterministic order)
  const allText: string[] = [];
  if (toolData?.key_facts) {
    const sortedFacts = [...toolData.key_facts].sort((a, b) => a.localeCompare(b));
    allText.push(...sortedFacts);
  }
  if (toolData?.highlights) {
    const sortedHighlights = [...toolData.highlights].sort((a, b) => a.localeCompare(b));
    allText.push(...sortedHighlights);
  }
  if (snapshotBullets) {
    const sortedBullets = [...snapshotBullets].sort((a, b) => a.localeCompare(b));
    allText.push(...sortedBullets);
  }
  
  // Collect plan text (deterministic order)
  const planTexts: string[] = [];
  if (plans) {
    const sortedPlans = [...plans].sort((a, b) => {
      const nameA = (a.name || '').toLowerCase();
      const nameB = (b.name || '').toLowerCase();
      return nameA.localeCompare(nameB);
    });
    
    for (const plan of sortedPlans) {
      const planText = [
        ...(plan.highlights || []),
        ...(plan.featureItems?.map(f => f.text) || []),
        ...(plan.features || []),
        plan.description || ''
      ].join(' ');
      planTexts.push(planText);
    }
  }
  
  // Include comparable attributes from Plans compared table
  const attributeTexts: string[] = [];
  if (comparableAttributes) {
    for (const attr of comparableAttributes) {
      if (attr.valuesByPlanId) {
        const values = Object.values(attr.valuesByPlanId).filter(v => v && v !== 'â€”' && v !== 'See plan details');
        attributeTexts.push(...(values as string[]));
      }
    }
  }
  
  const combinedText = [...allText, ...planTexts, ...attributeTexts].join(' ').toLowerCase();
  
  // Extract unique keywords and facts for deduplication
  const usedKeywords = new Set<string>();
  const extractedFacts = new Set<string>();
  
  // Sentence 1: Target audience with specific feature (positive focus only)
  const { target, specificFeature } = extractTargetAndFeature(toolData, plans, combinedText, usedKeywords, extractedFacts);
  const sentence1Pattern = styleProfile.sentence1_patterns[0]; // Use first pattern for determinism
  let sentence1 = sentence1Pattern
    .replace('{toolName}', toolName || 'This tool')
    .replace('{target}', target)
    .replace('{specific_feature}', specificFeature);
  
  // Ensure sentence1 has unique tool-specific content
  if (!sentence1.match(/\d+|\b(4k|1080p|720p|watermark|minutes|credits|avatars|scorm|saml|sso|gb|tb|hr|hours?|videos?|languages?)\b/i)) {
    // Inject specific feature from plans if missing
    const injectedFeature = extractSpecificFeature(planTexts, usedKeywords);
    if (injectedFeature) {
      sentence1 = sentence1.replace(specificFeature, injectedFeature);
    }
  }
  
  // Sentence 2: Value proposition (what you get) - avoid duplication
  const { differentiator, secondaryFeature } = extractValueProposition(planTexts, toolData, combinedText, usedKeywords, extractedFacts);
  const sentence2Pattern = styleProfile.sentence2_patterns[0]; // Use first pattern for determinism
  let sentence2 = sentence2Pattern
    .replace('{differentiator}', differentiator)
    .replace('{secondary_feature}', secondaryFeature);
  
  // Ensure no duplication with sentence1
  if (isContentDuplicated(sentence1, sentence2, extractedFacts)) {
    // Use alternative differentiator
    const altDifferentiator = extractAlternativeDifferentiator(planTexts, toolData, usedKeywords);
    sentence2 = sentence2Pattern
      .replace('{differentiator}', altDifferentiator || differentiator)
      .replace('{secondary_feature}', secondaryFeature);
  }
  
  // Sentence 3: Next steps (plan recommendation) - positive action focus
  const { planRecommendation, specificLimit } = extractPlanRecommendation(plans, usedKeywords, extractedFacts);
  const sentence3Pattern = styleProfile.sentence3_patterns[0]; // Use first pattern for determinism
  const sentence3 = sentence3Pattern
    .replace('{plan_recommendation}', planRecommendation)
    .replace('{specific_limit}', specificLimit);
  
  // Combine sentences (2-3 sentences total)
  const sentences = [sentence1.trim(), sentence2.trim(), sentence3.trim()].filter(s => s.length > 0);
  
  // Ensure exactly 2-3 sentences
  let finalSentences = sentences.slice(0, 3);
  if (finalSentences.length < 2) {
    finalSentences.push('Upgrade to access premium features and enhanced productivity.');
  }
  
  const result = finalSentences.join(' ');
  
  // Final validation: ensure tool-specific content exists
  const hasToolSpecificContent = result.match(/\d+|\b(4k|1080p|720p|watermark|minutes|credits|avatars|scorm|saml|sso|gb|tb|hr|hours?|videos?|languages?|scenes?|voices?)\b/i);
  
  if (!hasToolSpecificContent) {
    // Fallback with tool name and basic differentiator
    return `${toolName || 'This tool'} is perfect for content creators needing professional video production. You get watermark-free 1080p exports and advanced editing features. Start with the basic paid plan to test 60 minutes/month before upgrading.`;
  }
  
  return result;
}